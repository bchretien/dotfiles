" vim: set foldmethod=marker foldlevel=0 et ts=2 sw=2 sts=2:
" ============================================================================
" .nvimrc of bchretien
" ============================================================================

" Environment {{{
  " Identify platform 
  silent function! OSX()
    return has('macunix')
  endfunction
  silent function! LINUX()
    return has('unix') && !has('macunix') && !has('win32unix')
  endfunction
  silent function! WINDOWS()
    return (has('win16') || has('win32') || has('win64'))
  endfunction
" }}}

" Use plugins config {{{
  if filereadable(expand("~/.config/nvim/plugins.vim"))
    source ~/.config/nvim/plugins.vim
  endif
" }}}

" ============================================================================
" General {{{
" ============================================================================

" Assume a dark background
set background=dark
" Automatically detect file types.
filetype plugin indent on
" Syntax highlighting
syntax on
" Automatically enable mouse usage
set mouse=a
" Hide the mouse cursor while typing
set mousehide
" Default to UTF-8
scriptencoding utf-8
" Enable modelines
set modeline

" TODO: still relevant?
" Fix mouse in vim under tmux
if &term =~ '^screen'
  " tmux knows the extended mouse mode
  set ttymouse=xterm2
endif

" System clipboard support
set clipboard=unnamed,unnamedplus

" Abbrev. of messages (avoids 'hit enter')
set shortmess+=filmnrxoOtT
" Better Unix / Windows compatibility
set viewoptions=folds,options,cursor,unix,slash
" Allow virtual editing in Visual block mode
set virtualedit=block
" Store a ton of history (default is 20)
set history=1000
" Spell checking off
set nospell
" Allow buffer switching without saving
set hidden

" Splitting style
set splitbelow
set splitright

" Keep the window height when windows are opened or closed
set winfixheight

" Indent
set autoindent
filetype plugin indent on

" Optimization
set viminfo=<0,'10,/150,:100,h,f0,s10

" Default number of spaces for indent, tab behavior, etc.
set shiftwidth=2
set expandtab
set tabstop=2

" Swap, backup, undo {{{
  " Disable swap files
  set noswapfile
  " Disable backups
  set nobackup
  if has('persistent_undo')
    " Maximum number of changes that can be undone
    set undolevels=1000
    " Maximum number lines to save for undo on a buffer reload
    set undoreload=10000
    " Undo directory
    set undodir=~/.local/share/nvim/tmp/undo/
    " Undo file
    set undofile

    " Make those folders automatically if they don't already exist.
    if !isdirectory(expand(&undodir))
        call mkdir(expand(&undodir), "p")
    endif
  endif
" }}}

" }}}
" ============================================================================
" User Interface {{{
" ============================================================================

" Colors {{{
  " TODO: change cursor color on insert

  " Colorscheme
  colorscheme hybrid

  " Fix cursor in search for hybrid
  hi Cursor ctermfg=16 ctermbg=253

  " Fix spellchecking color
  hi clear SpellBad
  hi SpellBad cterm=underline ctermfg=red

  highlight clear SignColumn " SignColumn should match background
  highlight clear LineNr " Current line number row will have same background color in relative mode
  "highlight clear CursorLineNr " Remove highlight color from current line number

  au BufRead,BufWinEnter * if &diff || (v:progname =~ "diff") | set nocursorline | endif
" }}}

" Only show 15 tabs
set tabpagemax=15
" Display the current mode
set showmode
" Highlight current line
set cursorline

if has('cmdline_info')
  " Show the ruler
  set ruler
  set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
  set showcmd " Show partial commands in status line and
              " Selected characters/lines in visual mode
endif

set backspace=indent,eol,start " Backspace for dummies
set linespace=0 " No extra spaces between rows
" Line numbers on
set number
" Relative line numbers on
set relativenumber
" Show matching brackets/parenthesis
set showmatch
" Find as you type search
set incsearch
" Highlight search terms
set hlsearch
set winminheight=0 " Windows can be 0 line high
" Case insensitive search
set ignorecase
" Case sensitive when uc present
set smartcase
" Show list instead of just completing
set wildmenu
" Command <Tab> completion, list matches, then longest common part, then all
set wildmode=list:longest,full
" Backspace and cursor keys wrap too
set whichwrap=b,s,h,l,<,>,[,]
" Lines to scroll when cursor leaves screen
set scrolljump=5
" Minimum lines to keep above and below cursor
set scrolloff=3

" Highlight problematic whitespace
set list
set listchars=tab:>-,trail:~,extends:>,precedes:<

" Completion
set completeopt+=menuone
set completeopt-=preview

" Default Vim completion should not look for all include files (slow)
set complete-=i
" Default Vim completion should not look for all tags (slow)
set complete-=t

set linebreak
set wrap

" Disable colorcolumn (use vim-lengthmatters instead)
set colorcolumn=

" Folding
set foldmethod=indent
set foldenable
set foldlevel=100

" Optimization
set lazyredraw

" Syntax coloring lines that are too long really slows Vim down
set synmaxcol=200

" FIXME: useful?
set switchbuf=usetab

" }}}
" ============================================================================
" Functions {{{
" ============================================================================
" See: http://stackoverflow.com/a/6171215/1043187
" Escape special characters in a string for exact matching.
" This is useful to copying strings from the file to the search tool
" Based on this - http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim
function! EscapeString (string)
  let string=a:string
" Escape regex characters
  let string = escape(string, '^$.*\/~[]')
" Escape the line endings
  let string = substitute(string, '\n', '\\n', 'g')
  return string
endfunction

" Get the current visual block for search and replaces
" This function passed the visual block through a string escape function
" Based on this - http://stackoverflow.com/questions/676600/vim-replace-selected-text/677918#677918
function! GetVisual() range
  " Save the current register and clipboard
  let reg_save = getreg('"')
  let regtype_save = getregtype('"')
  let cb_save = &clipboard
  set clipboard&

  " Put the current visual selection in the " register
  normal! ""gvy
  let selection = getreg('"')

  " Put the saved registers and clipboards back
  call setreg('"', reg_save, regtype_save)
  let &clipboard = cb_save

  "Escape any special characters in the selection
  let escaped_selection = EscapeString(selection)

  return escaped_selection
endfunction

" }}}
" ============================================================================
" Autocmd {{{
" ============================================================================

" Fix autoindent in yaml
autocmd FileType yaml setl indentkeys-=<:>

" K to lookup current word in cppman
command! -nargs=+ Cppman silent! call system("tmux split-window cppman " . expand(<q-args>))
"autocmd FileType cpp set keywordprg="tmux split-window cppman"
autocmd FileType cpp nnoremap <silent><buffer> K <Esc>:Cppman <cword><CR>

" If doing a diff. Upon writing changes to file, automatically update the
" differences
autocmd BufWritePost * if &diff == 1 | diffupdate | endif

" Instead of reverting the cursor to the last position in the buffer, we
" set it to the first line when editing a git commit message
autocmd FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

" From Junegunn Choi's dotfiles
function! s:helptab()
  if &buftype == 'help'
    "wincmd T
    nnoremap <buffer> q :q<cr>
  endif
endfunction

augroup vimrc_help
  autocmd!
  autocmd BufEnter *.txt call s:helptab()
augroup END

" Don't show tabs/trailing whitespaces in man pages
autocmd FileType man set nolist

" Use :help with K
autocmd FileType vim set keywordprg=:bel\ help\ \|\ bot\ resize\ 20

" q closes location/quickfix/qfreplace list
autocmd FileType qf nnoremap <buffer> q :q<cr>
autocmd FileType qfreplace nnoremap <buffer> q :bd<cr>

" Fix Python/CMake comments style for UltiSnips
autocmd FileType python set comments=b:#
autocmd FileType cmake set comments=b:#
" }}}
" ============================================================================
" Mappings {{{

" Navigation
nnoremap j gj
nnoremap k gk
xnoremap j gj
xnoremap k gk

" Navigation for tabs
nnoremap th  :tabfirst<CR>
nnoremap tj  :tabprev<CR>
nnoremap tk  :tabnext<CR>
nnoremap tl  :tablast<CR>
nnoremap tm  :tabm<Space>
nnoremap tn  :tabnew<CR>
nnoremap td  :tabclose<CR>
nnoremap tt  :tabnext<CR>

" This unsets the "last search pattern" register by hitting return
nnoremap <CR> :noh<CR><CR>

" Leader
let mapleader = ','
let maplocalleader = ';'
nmap <Space> ,
vmap <Space> ,

" Grep-like search
nnoremap <Leader>/  :Agr 
vnoremap <Leader>/  y:Agr <C-R>=escape(@", '\\.*$^[]')<CR><CR>
" TODO: specify directory to look into
"nnoremap <Leader>// :Agr 

" Start the find and replace command from the cursor position to the end of
" the file
vmap <leader>z <Esc>:,$s/<c-r>=GetVisual()<cr>/
" Start the find and replace command across the whole file
vmap <leader>zz <Esc>:%s/<c-r>=GetVisual()<cr>/

" Enable 'very magic' mode
nnoremap / /\v
vnoremap / /\v
cnoremap %s/ %smagic/
cnoremap \>s/ \>smagic/

" Force saving files that require root permission with w!!
cmap w!! w !sudo tee % >/dev/null

" Easier formatting
nnoremap <silent> <leader>q gwip
vnoremap <silent> <leader>q gw
" }}}
" ============================================================================
" Plugins {{{
" ============================================================================
  " fzf.vim {{{
  if isdirectory(expand("~/.config/nvim/plugged/fzf.vim"))
    " Disable statusline overwriting
    let g:fzf_nvim_statusline = 0

    let g:fzf_action = {
          \ 'ctrl-s': 'split',
          \ 'ctrl-v': 'vsplit'
          \ }

    fun! s:fzf_root()
      let path = finddir(".git", expand("%:p:h").";")
      return expand(fnamemodify(substitute(path, ".git", "", ""), ":p:h"))
    endfun

    " Ctrl-P without fuzzy search
    nnoremap <c-p> :FZF -e --cycle<cr>

    " Ctrl-Space to see buffers
    " Note: <c-space> seen as <c-@> by neovim.
    " See: https://github.com/neovim/neovim/issues/2782
    nnoremap <c-@> :Buffers<cr>

    " List colorschemes
    autocmd VimEnter * command! Colors
      \ call fzf#vim#colors({'left': '15%', 'options': '--reverse --margin 30%,0'})

    function! s:ag_to_qf(line)
      let parts = split(a:line, ':')
      return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
            \ 'text': join(parts[3:], ':')}
    endfunction

    function! s:w(bang)
      return a:bang ? {} : copy(get(g:, 'fzf_layout', g:fzf#vim#default_layout))
    endfunction

    function! s:expect()
      return ' --expect='.join(keys(get(g:, 'fzf_action', g:fzf_action)), ',')
    endfunction

    function! s:escape(path)
      return escape(a:path, ' %#''"\')
    endfunction

    function! s:fzf_ag_handler(lines)
      echomsg "ag_handler"
      if len(a:lines) < 2
        return
      endif

      let cmd = get(get(g:, 'fzf_action', g:fzf_action), a:lines[0], 'e')
      let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

      let first = list[0]
      execute cmd s:escape(first.filename)
      execute first.lnum
      execute 'normal!' first.col.'|zz'

      if len(list) > 1
        call setqflist(list)
        wincmd p
        Qfreplace
      endif
    endfunction

    function! s:fzf_ag(query, ...)
      call fzf#run({
            \ 'source':  printf('ag --nogroup --column --color "%s"',
            \                   escape(empty(a:query) ? '^(?=.)' : a:query, '"\')),
            \ 'sink*':    function('s:fzf_ag_handler'),
            \ 'options': '--ansi --delimiter : --nth 4.. --prompt "Ag> " '.
            \            '--multi --bind ctrl-a:select-all,ctrl-d:deselect-all,tab:toggle-up,shift-tab:toggle-down '.
            \            '--cycle --color hl:68,hl+:110'.s:expect()}, a:000)
    endfunction

    " Ag + qfreplace
    command! -bang -nargs=* Agr call <sid>fzf_ag(<q-args>, s:w(<bang>0))
  endif
  " }}}
  " lightline.vim {{{
    if isdirectory(expand("~/.config/nvim/plugged/lightline.vim"))
      function! LightlineMode()
        let fname = expand('%:t')
        return fname == '__Tagbar__' ? 'Tagbar' :
              \ fname == 'ControlP' ? 'CtrlP':
              \ fname == '__Gundo__' ? 'Gundo' :
              \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
              \ fname =~ 'NERD_tree' ? 'NERDTree' :
              \ &ft == 'unite' ? 'Unite' :
              \ &ft == 'vimfiler' ? 'VimFiler' :
              \ &ft == 'vimshell' ? 'VimShell' :
              \ winwidth('.') > 60 ? lightline#mode() : ''
      endfunction

      let g:lightline = {
            \ 'colorscheme': 'murmur',
            \ 'enable': {
            \   'tabline': 1,
            \   'statusline': 1,
            \ },
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['tagbar'] ],
            \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
            \ },
            \ 'component': {
            \   'readonly': '%{&filetype=="help"?"":&readonly?"":""}',
            \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
            \   'fugitive': '%{exists("*fugitive#head")? " ".fugitive#head():""}',
            \   'tagbar':   '%{exists("*tagbar#currenttag")?tagbar#currenttag("[%s]", "", "f"):""}'
            \ },
            \ 'component_visible_condition': {
            \   'readonly': '(&filetype!="help"&& &readonly)',
            \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
            \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
            \ },
            \ 'component_function': {
            \   'mode': 'LightlineMode',
            \ },
            \ 'separator': { 'left': '', 'right': '' },
            \ 'subseparator': { 'left': '', 'right': '' }
            \ }

      let g:lightline.tabline = {
            \ 'left': [ [ 'tabs' ] ],
            \ 'right': [ [ 'close' ] ] }

      "let g:lightline.component_type = {
            "\ 'tabs': 'raw' }
    endif
  " }}}
  " startify {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-startify"))
      " Helper function to center header
      function! s:center_header(lines) abort
        let longest_line   = max(map(copy(a:lines), 'len(v:val)'))
        let centered_lines = map(copy(a:lines),
              \ 'repeat(" ", (&columns / 2) - (longest_line / 2)) . v:val')
        return centered_lines
      endfunction

      " Call fortune and cowsay (if present), and center the output
      let g:startify_custom_header =
        \ s:center_header(map(split(system('cowsay -f "$(ls /usr/share/cows/ | grep -vE "head|sod|kiss|surg|tele" | sort -R | head -1)" "$(fortune -s)"'), '\n'), '" ". v:val') + ['',''])

      " Skip list
      let g:startify_skiplist = [
        \ '^/tmp'
        \ ]

      " Number of files
      let g:startify_files_number = 5

      let g:startify_list_order = [['-- Bookmarks --'], 'bookmarks', ['-- Recent files --'], 'files']
      let g:startify_bookmarks = [ '~/.config/nvim/init.vim', '~/.config/nvim/plugins.vim' ]
    endif
  " }}}
  " supertab {{{
    if isdirectory(expand("~/.config/nvim/plugged/supertab"))
      let g:SuperTabDefaultCompletionType = '<Tab>'
      let g:SuperTabBackward = '<C-S-Tab>'
      let g:SuperTabCrMapping = 1
    endif
  " }}}
  " ultisnips {{{
    if isdirectory(expand("~/.config/nvim/plugged/ultisnips"))
      " Trigger configuration.
      let g:UltiSnipsExpandTrigger="<tab>"
      let g:UltiSnipsJumpForwardTrigger="<tab>"
      let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
      let g:UltiSnipsListSnippets="<c-tab>"

      " If you want :UltiSnipsEdit to split your window.
      let g:UltiSnipsEditSplit="vertical"

      " Custom snippets
      let g:UltiSnipsSnippetsDir = "~/.config/nvim/custom_snippets"
      let g:UltiSnipsSnippetDirectories=["UltiSnips", "custom_snippets"]

      " Prevent UltiSnips from stealing ctrl-k.
      augroup VimStartup
        autocmd!
        autocmd VimEnter * sil! iunmap <c-k>
      augroup end
    endif
  " }}}
  " vim-clang-format {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-clang-format"))
      " map to <Leader>cf in C++ code
      autocmd FileType c,cpp,objc nnoremap <buffer><Leader>cf :<C-u>ClangFormat<CR>
      autocmd FileType c,cpp,objc vnoremap <buffer><Leader>cf :ClangFormat<CR>
    endif
  " }}}
  " vim-commentary {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-commentary")) || isdirectory(expand("~/.config/nvim/plugged/tcomment_vim"))
      " For transition from nerdcommenter
      nmap <Leader>c<Space> gcc
      nmap <Leader>cc       gc
      vmap <Leader>c<Space> gcc
      vmap <Leader>cc       gc
    endif
  " }}}
  " vim-easy-align {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-easy-align"))
      " Start interactive EasyAlign in visual mode
      vmap <Enter> <Plug>(EasyAlign)

      " Start interactive EasyAlign with a Vim movement
      nmap <Leader>a <Plug>(EasyAlign)

      let g:easy_align_delimiters = {
      \ ' ': { 'pattern': ' ', 'left_margin': 0, 'right_margin': 0, 'stick_to_left': 0 },
      \ '+': { 'pattern': '+', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '-': { 'pattern': '-', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '=': { 'pattern': '===\|<=>\|\(&&\|||\|<<\|>>\)=\|=\~[#?]\?\|=>\|[:+/*!%^=><&|.-]\?=[#?]\?',
      \ 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ ':': { 'pattern': ':', 'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1 },
      \ ',': { 'pattern': ',', 'left_margin': 0, 'right_margin': 1, 'stick_to_left': 1 },
      \ '|': { 'pattern': '|', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '.': { 'pattern': '\.', 'left_margin': 0, 'right_margin': 0, 'stick_to_left': 0 },
      \ '&': { 'pattern': '\\\@<!&\|\\\\', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '{': { 'pattern': '(\@<!{', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '}': { 'pattern': '}', 'left_margin': 1, 'right_margin': 0, 'stick_to_left': 0 },
      \ '\': { 'pattern': '\\', 'left_margin': 1, 'right_margin': 0, 'stick_to_left': 0 },
      \ '<': { 'pattern': '<', 'left_margin': 1, 'right_margin': 0, 'stick_to_left': 0 },
      \ 'd': { 'pattern': ' \(\S\+\s*[;=]\)\@=', 'left_margin': 0, 'right_margin': 0},
      \ '#': { 'pattern': '#', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ '[': { 'pattern': '(\@<![', 'left_margin': 1, 'right_margin': 1, 'stick_to_left': 0 },
      \ ']': { 'pattern': ']', 'left_margin': 1, 'right_margin': 0, 'stick_to_left': 0 },
      \ }
    endif
  " }}}
  " vim-notes {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-notes"))
      let g:notes_directories=["~/.local/share/nvim/notes"]
      autocmd BufNewFile,BufRead *.note set filetype=notes
    endif
  " }}}
  " vim-sneak {{{
    if isdirectory(expand("~/.config/nvim/plugged/vim-sneak"))
      " Use Sneak as a minimalist alternative to EasyMotion
      let g:sneak#streak = 1
      let g:sneak#s_next = 1

      " Colors
      highlight SneakPluginTarget guifg=white guibg=red    ctermfg=white ctermbg=red
      highlight SneakStreakTarget guifg=white guibg=red    ctermfg=white ctermbg=red
      highlight SneakStreakMask   guifg=gray  guibg=red    ctermfg=gray  ctermbg=red
      highlight SneakPluginScope  guifg=black guibg=yellow ctermfg=black ctermbg=yellow

      "replace 'f' with 1-char Sneak
      nmap f <Plug>Sneak_f
      nmap F <Plug>Sneak_F
      xmap f <Plug>Sneak_f
      xmap F <Plug>Sneak_F
      omap f <Plug>Sneak_f
      omap F <Plug>Sneak_F

      "replace 't' with 1-char Sneak
      nmap t <Plug>Sneak_t
      nmap T <Plug>Sneak_T
      xmap t <Plug>Sneak_t
      xmap T <Plug>Sneak_T
      omap t <Plug>Sneak_t
      omap T <Plug>Sneak_T

      " nmap s <Plug>(SneakStreak)
      " nmap S <Plug>(SneakStreakBackward)
    endif
  " }}}
  " YouCompleteMe {{{
    if isdirectory(expand("~/.config/nvim/plugged/YouCompleteMe"))
      let g:ycm_key_list_select_completion = ['<Down>']
      " let g:ycm_key_invoke_completion = '<S-Space>'
      let g:ycm_key_invoke_completion = '<C-y>'
      let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
      let g:ycm_show_diagnostics_ui = 0
      let g:ycm_filepath_completion_use_working_dir = 1
    endif
  " }}}
" }}}
" ============================================================================
